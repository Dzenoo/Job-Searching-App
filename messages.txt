TYPES
type SeekerDirectMessagesTypes = {
  employerId: string;
  messages: MessageTypes[];
};

directMessages: SeekerDirectMessagesTypes[];

type EmployerDirectMessagesTypes = {
  seekerId: string;
  messages: MessageTypes[];
};

directMessages: EmployerDirectMessagesTypes[];

type MessageTypes = {
  createdAt: string;
  sender:
    | {
        email: string;
        image: string;
        name: string;
        _id: string;
      }
    | {
        emaiL: string;
        image: string;
        first_name: string;
        last_name: string;
        _id: string;
      };
  content: string;
};

ZOD
import zod from "zod";

export const MessageSchema = zod.object({
  content: zod
    .string()
    .min(1, { message: "First Name must be at least 1 characters long" })
    .max(300, { message: "First Name must be at most 300 characters long" }),
});

ACTIONS
export const createDirectMessages = async (
  seekerId: string,
  token: string
): Promise<ResponseMessageTypes> =>
  await postApiHandler(`employer/messages/${seekerId}`, {}, token);

export const getDirectMessages = async (
  token: string
): Promise<{
  directMessages: { seekerId: SeekerTypes; messages: MessageTypes[] }[];
}> => await getApiHandler(`employer/messages`, token);

export const getMessagesRoom = async (
  token: string,
  seekerId: string
): Promise<{
  messageRoom: { seekerId: SeekerTypes; messages: MessageTypes[] };
}> => await getApiHandler(`employer/messages/${seekerId}`, token);

COMPONENTS
import React from "react";
import { Send } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { typeMessage } from "@/lib/actions/shared.actions";

import { useForm } from "react-hook-form";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import { MessageSchema } from "@/lib/zod/messages";

type MessagesFormProps = {
  refetchMessages: () => void;
  token: string;
  employerId: string;
  seekerId: string;
};

type FormValues = z.infer<typeof MessageSchema>;

const MessagesForm: React.FC<MessagesFormProps> = ({
  refetchMessages,
  token,
  employerId,
  seekerId,
}) => {
  const {
    register,
    handleSubmit,
    reset,
    formState: { isValid, errors },
  } = useForm<FormValues>({
    resolver: zodResolver(MessageSchema),
  });

  const onSubmit = async (data: FormValues) => {
    try {
      await typeMessage(
        { content: data.content, sender: employerId },
        token,
        employerId,
        seekerId
      );

      refetchMessages();
      reset();
    } catch (error) {
      console.error("Error sending message:", error);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div className="flex gap-2">
        <Input
          type="text"
          placeholder="Type a message..."
          {...register("content")}
        />
        <Button disabled={!isValid} type="submit">
          <Send />
        </Button>
      </div>
      {errors.content && (
        <p className="text-red-500 text-sm mt-1">{errors.content.message}</p>
      )}
    </form>
  );
};

export default MessagesForm;
"use client";

import React from "react";
import MessagesNavbar from "./MessagesNavbar";

import { useQuery } from "react-query";
import { getDirectMessages } from "@/lib/actions/employers.actions";

import useAuthentication from "@/hooks/useAuthentication";

const MessagesLayout: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const { token } = useAuthentication().getCookieHandler();
  const { data: directMessagesData } = useQuery({
    queryFn: () => getDirectMessages(token!),
    queryKey: ["directMessages"],
  });

  return (
    <div className="flex h-screen gap-5">
      <div className="basis-[25%] flex flex-col h-full overflow-y-auto hide-scrollbar">
        <MessagesNavbar
          messagesData={directMessagesData?.directMessages || []}
        />
      </div>
      <div className="flex-grow flex flex-col h-full min-h-0 overflow-hidden">
        <div className="flex-grow overflow-auto">{children}</div>
      </div>
    </div>
  );
};

export default MessagesLayout;
import React from "react";

import { MessageTypes, SeekerTypes } from "@/types";
import { getImageUrl } from "@/lib/utils";
import { usePathname } from "next/navigation";

import Link from "next/link";
import { Avatar, AvatarImage } from "@/components/ui/avatar";
import { Card, CardContent, CardHeader } from "@/components/ui/card";

type MessagesNavbarProps = {
  messagesData: { seekerId: SeekerTypes; messages: MessageTypes[] }[];
};

const MessagesNavbar: React.FC<MessagesNavbarProps> = ({ messagesData }) => {
  const pathname = usePathname();

  const isActiveChatSeeker = pathname.split("/rooms/")[1];

  return (
    <Card className="h-full">
      <CardHeader>
        <div>
          <h1 className="text-base-black">Messages</h1>
        </div>
      </CardHeader>
      <CardContent className="h-full pt-0">
        {messagesData === undefined ? (
          <div>
            <p className="text-initial-gray">Messages will appear here</p>
          </div>
        ) : (
          <div className="flex flex-col gap-5 overflow-auto">
            {messagesData.map((messages) => (
              <Link
                key={messages.seekerId._id}
                href={`/dashboard/messages/rooms/${messages.seekerId._id}`}
              >
                <div
                  className={`p-2 flex gap-5 items-center transition-all hover:bg-gray-100 dark:hover:bg-[#1b1b1b] rounded-lg cursor-pointer overflow-hidden ${
                    isActiveChatSeeker === messages.seekerId._id &&
                    "bg-blue-100 dark:bg-blue-700"
                  }`}
                >
                  <div>
                    <Avatar className="w-12 h-12">
                      <AvatarImage src={getImageUrl(messages.seekerId.image)} />
                    </Avatar>
                  </div>
                  <div>
                    <div>
                      <h1 className="text-initial-black whitespace-nowrap">
                        {messages.seekerId.first_name}{" "}
                        {messages.seekerId.last_name}
                      </h1>
                    </div>
                  </div>
                </div>
              </Link>
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  );
};

export default MessagesNavbar;
import React, { useEffect, useState } from "react";
import MessagesForm from "./MessagesForm";
import { MessageTypes, SeekerTypes } from "@/types";
import useAuthentication from "@/hooks/useAuthentication";
import { Avatar, AvatarImage } from "@/components/ui/avatar";
import { formatDate, getImageUrl } from "@/lib/utils";
import { getMessagesRoom } from "@/lib/actions/employers.actions";

type MessagesRoomProps = {
  data: {
    seekerId: SeekerTypes;
    messages: MessageTypes[];
  };
};

const MessagesRoom: React.FC<MessagesRoomProps> = ({ data }) => {
  const { token, userId: employerId } = useAuthentication().getCookieHandler();
  const [messages, setMessages] = useState<MessageTypes[]>([]);
  const [loading, setLoading] = useState<boolean>(false);

  useEffect(() => {
    if (data?.messages) {
      setMessages(data.messages);
    }
  }, [data]);

  const refetchMessages = async () => {
    setLoading(true);
    try {
      const updatedData = await getMessagesRoom(token!, data.seekerId._id);
      setMessages(updatedData?.messageRoom.messages || []);
    } catch (error) {
      console.error("Error refetching messages:", error);
    } finally {
      setLoading(false);
    }
  };

  const getSenderName = (sender: MessageTypes["sender"]) => {
    if ("name" in sender) {
      return sender.name;
    } else {
      return `${sender.first_name} ${sender.last_name}`;
    }
  };

  return (
    <div className="flex flex-col gap-2">
      <div>
        <h1 className="text-base-black">
          {data?.seekerId.first_name} {data?.seekerId.last_name}
        </h1>
      </div>
      <div className="h-[80vh] border rounded-lg overflow-y-scroll relative">
        {loading && <p className="text-initial-gray">Loading...</p>}
        {messages?.length === 0 && !loading && (
          <div className="flex items-center justify-center">
            <p className="text-initial-gray">No Messages</p>
          </div>
        )}
        <div className="p-2 flex flex-col gap-1">
          {messages?.length !== 0 &&
            messages?.map((message, index) => {
              const isCurrentUser = message.sender._id === employerId;
              return (
                <div
                  key={index}
                  className={`relative p-4 rounded-lg flex gap-2 w-full items-center ${
                    isCurrentUser ? "justify-end" : "justify-start"
                  }`}
                >
                  {!isCurrentUser && (
                    <div>
                      <Avatar className="w-12 h-12">
                        <AvatarImage src={getImageUrl(message?.sender.image)} />
                      </Avatar>
                    </div>
                  )}
                  <div
                    className={`pt-5 flex flex-col ${
                      isCurrentUser ? "items-end" : "items-start"
                    }`}
                  >
                    {!isCurrentUser && (
                      <div>
                        <h1 className="font-semibold">
                          {getSenderName(message.sender)}
                        </h1>
                      </div>
                    )}
                    <div>
                      <p className="bg-gray-100 p-2 rounded-lg shadow-md text-initial-gray">
                        {message.content}
                      </p>
                      <span className="text-xs text-gray-500 block mt-1">
                        {formatDate(message.createdAt)}
                      </span>
                    </div>
                  </div>
                  {isCurrentUser && (
                    <div>
                      <Avatar className="w-12 h-12">
                        <AvatarImage src={getImageUrl(message?.sender.image)} />
                      </Avatar>
                    </div>
                  )}
                </div>
              );
            })}
        </div>
      </div>
      <div>
        <MessagesForm
          refetchMessages={refetchMessages}
          token={token!}
          employerId={employerId!}
          seekerId={data?.seekerId._id}
        />
      </div>
    </div>
  );
};

export default MessagesRoom;
"use client";

import React, { useEffect } from "react";
import Protected from "@/components/hoc/Protected";
import useOverflow from "@/hooks/useOverflow";
import Image from "next/image";
import Link from "next/link";

import { Button } from "@/components/ui/button";
import useAuthentication from "@/hooks/useAuthentication";
import { useQuery } from "react-query";
import { getDirectMessages } from "@/lib/actions/employers.actions";
import { useRouter } from "next/navigation";

const RoomsPage = () => {
  const { token } = useAuthentication().getCookieHandler();
  const { data: directMessagesData } = useQuery({
    queryFn: () => getDirectMessages(token!),
    queryKey: ["directMessages"],
  });
  const router = useRouter();

  useEffect(() => {
    if (directMessagesData && directMessagesData?.directMessages.length > 0) {
      router.push(
        `/dashboard/messages/rooms/${directMessagesData?.directMessages[0].seekerId._id}`
      );
    }
  }, [directMessagesData]);

  useOverflow("rooms");

  return (
    <div className="flex justify-center items-center gap-5 flex-col">
      <div>
        <Image
          src="/images/messages.png"
          alt="messages"
          width={500}
          height={500}
        />
      </div>
      <div>
        <h1 className="text-base-black">Welcome To Messages</h1>
      </div>
      <div>
        <p className="text-initial-gray">
          Once you create chat with seeker it will appear here{" "}
        </p>
      </div>
      <div>
        <Link href="/seekers">
          <Button variant="default">Search Seekers</Button>
        </Link>
      </div>
    </div>
  );
};

export default Protected(RoomsPage, ["employer"]);
import MessagesLayout from "@/components/employers/dashboard/messages/MessagesLayout";
import React from "react";

const RoomsLayout = ({ children }: { children: React.ReactNode }) => {
  return <MessagesLayout children={children} />;
};

export default RoomsLayout;
"use client";

import React from "react";

import MessagesRoom from "@/components/employers/dashboard/messages/MessagesRoom";
import Protected from "@/components/hoc/Protected";
import useAuthentication from "@/hooks/useAuthentication";
import useOverflow from "@/hooks/useOverflow";
import { getMessagesRoom } from "@/lib/actions/employers.actions";
import { useQuery } from "react-query";

const RoomPage = ({ params }: { params: { seekerId: string } }) => {
  const { token } = useAuthentication().getCookieHandler();
  const { data: messageRoomData } = useQuery({
    queryFn: () => getMessagesRoom(token!, params.seekerId),
  });

  useOverflow("rooms");

  return (
    <div>
      <MessagesRoom data={messageRoomData?.messageRoom!} />
    </div>
  );
};

export default Protected(RoomPage, ["employer"]);


 // Messages
    {
      method: EXPRESS_APP_METHODS.PATCH,
      path: "/create-message/:employerId/:seekerId",
      handlers: [messages.createMessage],
    },
    {
      method: EXPRESS_APP_METHODS.POST,
      path: "/employer/messages/:seekerId",
      handlers: [messages.createDirectMessages],
    },
  {
      method: EXPRESS_APP_METHODS.GET,
      path: "/employer/messages",
      handlers: [employers.getDirectMessages],
    },
    {
      method: EXPRESS_APP_METHODS.GET,
      path: "/employer/messages/:seekerId",
      handlers: [employers.getMessageRoom],
    },






    import { asyncErrors } from "../errors/asyncErrors";
import Employer from "../models/employer/employers.schema";
import Seeker from "../models/seeker/seekers.schema";
import Message from "../models/shared/messages.schema";
import { io } from "../server";
import { sendResponse } from "../utils/validation";

// Controller function to create a direct messaging channel between an employer and a seeker
export const createDirectMessages = asyncErrors(async (request, response) => {
  try {
    // Get the employerId from the authenticated user and seekerId from the request parameters
    // @ts-ignore
    const { employerId } = request.user;
    const { seekerId } = request.params;

    // Find the existing employer and seeker by their IDs
    const existingEmployer = await Employer.findById(employerId);
    const existingSeeker = await Seeker.findById(seekerId);

    // Check if the employer or seeker does not exist
    if (!existingEmployer || !existingSeeker) {
      return sendResponse(
        {
          message:
            "The specified employer or seeker could not be found. Please check the IDs and try again",
        },
        404,
        response
      );
    }

    // Check if direct messages already exist between the employer and seeker
    const existingDirectMessages = existingEmployer.directMessages.find(
      (message: any) => message.seekerId.toString() === seekerId.toString()
    );

    if (existingDirectMessages) {
      return sendResponse(
        {
          message:
            "A direct messaging channel between this employer and seeker already exists.",
        },
        400,
        response
      );
    }

    // Prepare direct message data for both employer and seeker
    const directMessagesEmployerData = {
      seekerId: seekerId,
      messages: [],
    };

    const directMessagesSeekerData = {
      employerId: employerId,
      messages: [],
    };

    // Add the direct message entry to both employer and seeker
    await Employer.findByIdAndUpdate(
      employerId,
      {
        $push: { directMessages: directMessagesEmployerData },
      },
      {
        new: true,
      }
    );

    await Seeker.findByIdAndUpdate(
      seekerId,
      {
        $push: { directMessages: directMessagesSeekerData },
      },
      {
        new: true,
      }
    );

    // Send a success response
    sendResponse(
      { message: "Direct messages successfully created" },
      201,
      response
    );
  } catch (error) {
    // Handle any errors during the process
    sendResponse(
      { message: "Cannot create direct messages, please try again" },
      400,
      response
    );
  }
});

// Controller function to create a new message within an existing direct messaging channel
export const createMessage = asyncErrors(async (request, response) => {
  try {
    // Get the sender and content of the message from the request body
    const { sender, content } = request.body;
    // Get the employerId and seekerId from the request parameters
    const { employerId, seekerId } = request.params;

    // Find the existing employer and seeker by their IDs
    const existingEmployer = await Employer.findById(employerId);
    const existingSeeker = await Seeker.findById(seekerId);

    // Check if the employer or seeker does not exist
    if (!existingEmployer || !existingSeeker) {
      return sendResponse(
        {
          message:
            "The specified employer or seeker could not be found. Please check the IDs and try again.",
        },
        404,
        response
      );
    }

    // Check if direct messages exist between the employer and seeker
    const existingDirectMessages = existingEmployer.directMessages.find(
      (message: any) => message.seekerId.toString() === seekerId.toString()
    );

    if (!existingDirectMessages) {
      return sendResponse(
        {
          message:
            "No direct messaging channel exists between this employer and seeker. Please create one first.",
        },
        404,
        response
      );
    }

    // Create a new message in the database
    const newMessage = await Message.create({
      sender: sender,
      content: content,
    });

    // Add the message to the direct message thread for both employer and seeker
    await Employer.findByIdAndUpdate(
      employerId,
      {
        $push: {
          "directMessages.$[elem].messages": newMessage._id,
        },
      },
      {
        arrayFilters: [{ "elem.seekerId": seekerId }],
      }
    );

    await Seeker.findByIdAndUpdate(
      seekerId,
      {
        $push: {
          "directMessages.$[elem].messages": newMessage._id,
        },
      },
      {
        arrayFilters: [{ "elem.employerId": employerId }],
      }
    );

    // Emit the new message event to the specific socket room
    io.to(`${employerId}-${seekerId}`).emit("newMessage", newMessage);

    // Send a success response
    sendResponse({ message: "Message successfully sent" }, 201, response);
  } catch (error) {
    // Handle any errors during the process
    sendResponse(
      { message: "Cannot send message, please try again" },
      400,
      response
    );
  }
});


export const getDirectMessages = asyncErrors(async (request, response) => {
  try {
    // @ts-ignore
    const { employerId } = request.user;

    const employer = await Employer.findById(employerId)
      .populate({
        path: "directMessages.seekerId",
        select: "first_name last_name email image",
      })
      .populate({
        path: "directMessages.messages",
        select: "content createdAt",
      });

    if (!employer) {
      return sendResponse(
        { message: "Cannot find employer profile" },
        400,
        response
      );
    }

    sendResponse({ directMessages: employer.directMessages }, 200, response);
  } catch (error) {
    response.status(500).json({ message: "Internal server error" });
  }
});

export const getMessageRoom = asyncErrors(async (request, response) => {
  try {
    // @ts-ignore
    const { employerId } = request.user;
    const { seekerId } = request.params;

    const employer = await Employer.findById(employerId)
      .populate({
        path: "directMessages.seekerId",
        match: { _id: seekerId },
        select: "first_name last_name email image",
      })
      .populate({
        path: "directMessages.messages",
        select: "content createdAt sender",
      });

    if (!employer) {
      return sendResponse(
        { message: "Cannot find employer profile" },
        400,
        response
      );
    }

    const messageRoom = employer.directMessages.find(
      (dm: any) => dm.seekerId && dm.seekerId._id.toString() === seekerId
    );

    if (!messageRoom) {
      return sendResponse(
        { message: "Message room not found for this seeker" },
        404,
        response
      );
    }

    // Convert the messageRoom and its messages to plain JavaScript objects
    const plainMessageRoom = messageRoom.toObject();

    // Now manually populate the sender's information based on whether it's a Seeker or Employer
    const populatedMessages = await Promise.all(
      plainMessageRoom.messages.map(async (msg: any) => {
        if (msg.sender.equals(employerId)) {
          // If sender is the employer
          const sender = await Employer.findById(employerId)
            .select("name email image")
            .lean(); // Use .lean() to get plain objects
          return { ...msg, sender };
        } else {
          // If sender is the seeker
          const sender = await Seeker.findById(msg.sender)
            .select("first_name last_name email image")
            .lean(); // Use .lean() to get plain objects
          return { ...msg, sender };
        }
      })
    );

    // Respond with the plain populated messages
    sendResponse(
      { messageRoom: { ...plainMessageRoom, messages: populatedMessages } },
      200,
      response
    );
  } catch (error) {
    response.status(500).json({ message: "Internal server error" });
  }
});

import mongoose from "mongoose";

const MessageSchema = new mongoose.Schema(
  {
    sender: {
      type: mongoose.Types.ObjectId,
      required: [true, "Sender must be defined"],
    },
    content: {
      type: String,
      minlength: [1, "Message cannot be empty"],
      maxlength: [300, "Message cannot be longer"],
      required: [true, "Message cannot be empty"],
    },
  },
  { timestamps: true }
);
const Message =
  mongoose.models.Message || mongoose.model("Message", MessageSchema);

export default Message;

   directMessages: [
      {
        _id: false,
        seekerId: { type: mongoose.Types.ObjectId, ref: "Seeker" },
        messages: [
          { type: mongoose.Types.ObjectId, ref: "Message", default: [] },
        ],
      },
    ],

    import { Button } from "@/components/ui/button";
import { toast } from "@/components/ui/use-toast";
import { queryClient } from "@/context/react-query-client";
import useGetEmployer from "@/hooks/mutations/useGetEmployer";
import useAuthentication from "@/hooks/useAuthentication";
import { createDirectMessages } from "@/lib/actions/employers.actions";
import Link from "next/link";
import { useRouter } from "next/navigation";
import React from "react";
import { useMutation } from "react-query";
import { ClipLoader } from "react-spinners";

type CreateDirectMessagesButtonProps = {
  seekerId: string;
};

const CreateDirectMessagesButton: React.FC<CreateDirectMessagesButtonProps> = ({
  seekerId,
}) => {
  const { data } = useGetEmployer();
  const router = useRouter();
  const { token } = useAuthentication().getCookieHandler();
  const { mutateAsync: createDirectMessagesMutate, isLoading } = useMutation({
    mutationFn: () => createDirectMessages(seekerId, token!),
    onSuccess: () => {
      router.push(`/dashboard/messages/rooms/${seekerId}`);
      queryClient.invalidateQueries(["profile, seeker"]);
    },
    onError: (error: any) => {
      toast({ title: "Error", description: error.response.data.message });
    },
  });

  const isExistingDirectMessages = data?.employer.directMessages.find(
    (direct) => direct.seekerId === seekerId
  );

  return (
    <>
      {isExistingDirectMessages ? (
        <Link
          href={`/dashboard/messages/rooms/${isExistingDirectMessages.seekerId}`}
        >
          <Button variant="default">Message</Button>
        </Link>
      ) : (
        <Button
          disabled={isLoading}
          onClick={async () => await createDirectMessagesMutate()}
          variant="default"
        >
          {isLoading ? <ClipLoader /> : "Start"}
        </Button>
      )}
    </>
  );
};

export default CreateDirectMessagesButton;
